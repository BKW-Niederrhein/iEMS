<!DOCTYPE html>

<html lang="de">
<head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="#317EFB" name="theme-color"/><link href="manifest.json" rel="manifest"/><link href="icons/icon-192.png" rel="icon" type="image/png"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>iEMS Energieanalyse</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
<style>
        /* Modernisiertes, helles Farbschema */
        body {
            background-color: #fafafa; /* Sehr helles Weiß/Grau für mehr Kontrast */
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }
        .container {
            max-width: 1400px;
        }
        /* Style für die Farbpunkte in der Legende */
        .color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }
    </style>
</head>
<body class="p-6">
<div class="container mx-auto bg-white p-10 rounded-2xl shadow-2xl">
<div class="flex items-center mb-8">
<img alt="BKW-NR Logo" class="h-14 mr-6 self-center drop-shadow-md" src="BKW-NR_Logo_Schrift.png"/>
<h1 class="text-4xl font-extrabold text-gray-900 flex-1 text-center tracking-tight">iEMS Energieanalyse</h1>
<div class="w-20 h-14"></div>
</div>
<div class="flex items-center justify-between mb-10 p-5 border border-gray-100 rounded-xl bg-gray-50 shadow-inner">
<div class="flex items-center space-x-4">
<input accept=".iEMS, .csv" class="hidden" id="file-selector" multiple="" type="file"/>
<label class="cursor-pointer bg-blue-700 hover:bg-blue-800 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-0.5" for="file-selector" id="load-button">
                    Lade iEMS Dateien (config.iEMS und alle CSVs)
                </label>
</div>
<p class="text-base text-gray-500 font-medium" id="file-status">Bitte wählen Sie **config.iEMS** und alle zugehörigen **CSV**-Dateien aus.</p>
</div>
<div class="text-red-700 font-extrabold text-lg text-center mb-6 p-3 bg-red-50 border border-red-300 rounded-lg hidden" id="error-message"></div>
<div class="mb-12 bg-white p-8 rounded-2xl shadow-xl border border-gray-100">
<div class="flex justify-between items-start mb-6">
<h2 class="text-2xl font-bold text-gray-800 border-b-2 border-blue-200 pb-1">1. Energieflüsse (kWh)</h2>
</div>
<div class="h-[690px]"> <canvas id="chart-kwh"></canvas>
</div>
</div>
<div class="bg-white p-8 rounded-2xl shadow-xl border border-gray-100">
<div class="flex justify-between items-start mb-6">
<h2 class="text-2xl font-bold text-gray-800 border-b-2 border-blue-200 pb-1">2. Kosten/Ersparnis (€)</h2>
</div>
<div class="h-[690px]"> <canvas id="chart-euro"></canvas>
</div>
</div>
</div>
<script>
        Chart.register(ChartDataLabels);

        document.getElementById('file-selector').addEventListener('change', handleFileSelect);

        const STATUS_ELEMENT = document.getElementById('file-status');
        const ERROR_ELEMENT = document.getElementById('error-message');

        const COLORS = {
            zentral: 'rgba(59, 130, 246, 1)',  // Blau (Verbrauch)
            einspeisung: 'rgba(239, 68, 68, 1)', // Rot (Netzeinspeisung)
            gesamt: 'rgba(249, 115, 22, 1)',   // Orange (Gesamtsaldo)
            // Verschiedene Grüntöne für die PV-Erzeuger
            erzeuger: [
                'rgba(16, 185, 129, 1)',  // Emerald 500
                'rgba(5, 150, 105, 1)',   // Emerald 600
                'rgba(4, 120, 87, 1)',    // Emerald 700
                'rgba(34, 197, 94, 1)',   // Green 500
                'rgba(22, 163, 74, 1)',   // Green 600
                'rgba(21, 128, 61, 1)',   // Green 700
                'rgba(52, 211, 153, 1)',  // Teal 500
                'rgba(13, 148, 136, 1)',  // Teal 600
                'rgba(6, 95, 70, 1)',     // Emerald 800
                'rgba(20, 83, 45, 1)'     // Green 800
            ]
        };

        async function handleFileSelect(event) {
            const files = event.target.files;
            ERROR_ELEMENT.classList.add('hidden');
            STATUS_ELEMENT.textContent = 'Dateien werden geladen und analysiert...';

            if (!files.length) {
                STATUS_ELEMENT.textContent = 'Bitte wählen Sie config.iEMS und alle zugehörigen CSV-Dateien aus.';
                return;
            }

            try {
                const fileMap = new Map();
                let configFile = null;

                for (const file of files) {
                    fileMap.set(file.name, file);
                    if (file.name.toLowerCase() === 'config.iems') {
                        configFile = file;
                    }
                }

                if (!configFile) {
                    throw new Error("Die Datei 'config.iEMS' wurde nicht gefunden.");
                }

                const configText = await configFile.text();
                const config = parseConfig(configText);

                // Datenstruktur angepasst: Nun wird Netzeinspeisung als eigener Schlüssel in dataByMonth gespeichert.
                const allData = await loadAndProcessAllData(config, fileMap);
                
                const chartData = prepareChartData(allData, config.costPerKWH);

                renderCharts(chartData);

                STATUS_ELEMENT.textContent = `Analyse erfolgreich für ${Object.keys(allData.dataByMonth).length} Monate.`;
            } catch (error) {
                ERROR_ELEMENT.textContent = `Fehler bei der Datenverarbeitung: ${error.message}`;
                ERROR_ELEMENT.classList.remove('hidden');
                STATUS_ELEMENT.textContent = 'Bitte wählen Sie config.iEMS und alle zugehörigen CSV-Dateien aus.';
                console.error(error);
            }
        }

        function parseConfig(text) {
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const config = { centralFile: null, producerFiles: [], costPerKWH: 0.0 };

            for (const line of lines) {
                if (line.startsWith('iEMS Zentraldatei:')) {
                    config.centralFile = line.split(':')[1].trim();
                } else if (line.startsWith('Erzeugung_')) {
                    config.producerFiles.push(line.split(':')[1].trim());
                } else if (line.startsWith('Cent pro Kilowattstunde:')) {
                    const costStr = line.split(':')[1].trim().replace('€/kWh', '').replace(',', '.');
                    config.costPerKWH = parseFloat(costStr); 
                }
            }

            if (!config.centralFile) {
                throw new Error("Konnte die iEMS Zentraldatei nicht in der Konfiguration finden.");
            }
            return config;
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error(`Fehler beim Lesen der Datei ${file.name}: ${e.target.result}`));
                reader.readAsText(file);
            });
        }

        // NEUE HILFSFUNKTION FÜR ZENTRALDATEI
        function extractCentralNetData(lines, dataByMonth) {
            const START_TAG = 'Gesamtzurückgespeist';
            let startLineIndex = -1;

            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes(START_TAG)) {
                    if (i + 1 < lines.length && lines[i + 1].includes('Zeit,Wh')) {
                        startLineIndex = i + 2; 
                        break;
                    }
                }
            }

            if (startLineIndex === -1) {
                console.warn(`Start-Tag '${START_TAG}' in Zentral-CSV nicht gefunden.`);
                return;
            }

            for (let i = startLineIndex; i < lines.length; i++) {
                let line = lines[i];
                if (!line) continue;

                // Stoppkriterium: Ende der Datei oder nächster Abschnitt
                if (line.includes('PhaseA') || line.includes('PhaseB') || line.includes('PhaseC')) break;

                const parts = line.split(',');
                if (parts.length >= 2) {
                    const dateTimePart = parts[0].trim();
                    let valuePart = parts[1].trim();

                    if (!dateTimePart || !valuePart) continue;

                    const dateMatch = dateTimePart.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
                    if (!dateMatch) continue; 

                    const [, day, month, year] = dateMatch;
                    const date = new Date(Date.UTC(year, month - 1, day)); 
                    
                    const monthYear = date.toLocaleDateString('de-DE', { month: 'short', year: 'numeric' });
                    const formattedMonthYear = monthYear.replace(/\.$|^([A-Za-z]{3})$/g, '$1.').replace(/\.$/, '').replace(/(\w+)\s+(\d+)/, '$1. $2');
                    
                    let wh = parseFloat(valuePart.replace(',', '.'));
                    
                    if (isNaN(wh)) continue; 
                    if (wh >= 0) continue; // Nur zurückgespeiste (negative) Werte berücksichtigen

                    let kwh = wh / 1000.0;
                    
                    // Gesamtverbrauch anpassen (Summierung)
                    if (dataByMonth[formattedMonthYear]) {
                        // Der Netzeinspeisungswert (kwh) ist negativ und wird direkt zur Gesamtbilanz addiert
                        dataByMonth[formattedMonthYear].total += kwh; 
                        
                        // Für das Chart muss der Wert als "Netzeinspeisung" gespeichert werden
                        // WICHTIG: Er bleibt negativ, damit er als rote Säule nach unten zeigt.
                        dataByMonth[formattedMonthYear]['net_feed_in'] = kwh; 
                    }
                }
            }
        }


        /**
         * Extrahiert die relevanten Daten aus dem CSV-Inhalt.
         * HINWEIS: Jetzt nur für Verbrauch (Central) und Erzeugung (Producer)
         */
        function extractDataFromCSV(content, isCentral) {
            const data = [];
            const lines = content.split('\n').map(line => line.trim().replace(/\s/g, '').replace(' ', '')); 

            let startTag = isCentral ? 'Gesamt' : 'Gesamtzurückgespeist';
            let endTag = isCentral ? 'PhaseAzurückgespeist' : 'ENDE_DER_DATEI';

            let startLineIndex = -1;

            for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes(startTag)) {
                    if (i + 1 < lines.length && lines[i + 1].includes('Zeit,Wh')) {
                        startLineIndex = i + 2; 
                        break;
                    }
                }
            }

            if (startLineIndex === -1) {
                // Bei PV-Dateien ist das Start-Tag 'Gesamtzurückgespeist', bei Zentral 'Gesamt'
                if (isCentral) {
                    console.warn(`Start-Tag 'Gesamt' in Zentral-CSV nicht gefunden.`);
                }
                return data;
            }
            
            for (let i = startLineIndex; i < lines.length; i++) {
                let line = lines[i];
                if (!line) continue;

                if (isCentral && line.includes(endTag)) {
                    break;
                }
                // Stop-Kriterium für PV-Dateien ist bereits 'Gesamtzurückgespeist' -> ende der Datei
                if (!isCentral && line.includes('PhaseA')) {
                    break;
                }

                const parts = line.split(',');
                if (parts.length >= 2) {
                    const dateTimePart = parts[0].trim();
                    let valuePart = parts[1].trim();

                    if (!dateTimePart || !valuePart) continue;

                    const dateMatch = dateTimePart.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
                    if (!dateMatch) continue; 

                    const [, day, month, year] = dateMatch;
                    const date = new Date(Date.UTC(year, month - 1, day)); 
                    
                    const monthYear = date.toLocaleDateString('de-DE', { month: 'short', year: 'numeric' });
                    const formattedMonthYear = monthYear.replace(/\.$|^([A-Za-z]{3})$/g, '$1.').replace(/\.$/, '').replace(/(\w+)\s+(\d+)/, '$1. $2');
                    
                    let wh = parseFloat(valuePart.replace(',', '.'));
                    
                    if (isNaN(wh)) continue; 
                    
                    let kwh = wh / 1000.0;
                    
                    // Erzeuger: mit -1 multiplizieren (soll positiv sein, da im Stack 0)
                    if (!isCentral) {
                        if (kwh > 0) continue; // Nur zurückgespeiste (negative) Werte
                        kwh *= -1;
                    } else {
                        if (kwh < 0) continue; // Nur positiver Verbrauch
                    }

                    data.push({ monthYear: formattedMonthYear, kwh: kwh });
                }
            }

            return data.filter(item => item.kwh !== 0); 
        }

        async function loadAndProcessAllData(config, fileMap) {
            const dataByMonth = {}; 

            // 1. Zentraldatei (Verbrauch und Netzeinspeisung)
            const centralFile = fileMap.get(config.centralFile);
            if (centralFile) {
                const fileContent = await readFileAsText(centralFile);
                const lines = fileContent.split('\n').map(line => line.trim().replace(/\s/g, '').replace(' ', '')); 
                
                // Verbrauchsteil ('Gesamt') parsen
                const centralConsumptionData = extractDataFromCSV(fileContent, true);
                for (const { monthYear, kwh } of centralConsumptionData) {
                    if (!dataByMonth[monthYear]) {
                        // Setze den initialen Saldo auf den Verbrauchswert
                        dataByMonth[monthYear] = { central: 0, net_feed_in: 0, total: 0 }; 
                    }
                    dataByMonth[monthYear].central = kwh;
                    dataByMonth[monthYear].total += kwh;
                }

                // Netzeinspeisungsteil ('Gesamt zurückgespeist') parsen und direkt zu dataByMonth hinzufügen
                extractCentralNetData(lines, dataByMonth);
            }

            // 2. Erzeugerdateien (PV)
            for (const fileName of config.producerFiles) {
                const file = fileMap.get(fileName);
                if (!file) continue; 

                const fileContent = await readFileAsText(file);
                const dataKey = fileName;
                const rawData = extractDataFromCSV(fileContent, false); // isCentral=false (PV-Erzeugung)

                for (const { monthYear, kwh } of rawData) {
                    if (!dataByMonth[monthYear]) {
                        dataByMonth[monthYear] = { central: 0, net_feed_in: 0, total: 0 };
                    }
                    
                    dataByMonth[monthYear][dataKey] = kwh;
                    dataByMonth[monthYear].total += kwh;
                }
            }
            
            // Monate sortieren und fehlende Keys initialisieren
            const sortedMonths = Object.keys(dataByMonth).sort((a, b) => {
                const normalizeMonth = (m) => m.replace('Sept.', 'Sep.');
                const dateA = new Date(normalizeMonth(a));
                const dateB = new Date(normalizeMonth(b));
                return dateA - dateB;
            });
            
            const sortedDataByMonth = {};
            for (const month of sortedMonths) {
                sortedDataByMonth[month] = dataByMonth[month];
                // Sicherstellen, dass alle Keys vorhanden sind
                sortedDataByMonth[month].central = sortedDataByMonth[month].central || 0;
                sortedDataByMonth[month].net_feed_in = sortedDataByMonth[month].net_feed_in || 0;
                config.producerFiles.forEach(fileName => {
                    sortedDataByMonth[month][fileName] = sortedDataByMonth[month][fileName] || 0;
                });
            }

            return { dataByMonth: sortedDataByMonth, producerFiles: config.producerFiles };
        }

        /**
         * Bereitet die Daten für Chart.js vor.
         */
        function prepareChartData(allData, costPerKWH) {
            const months = Object.keys(allData.dataByMonth);
            const datasetsKWH = [];
            const datasetsEuro = [];
            let colorIndex = 0;

            // 1. Zentraler Verbrauch (Positive Säule)
            const centralDataKWH = months.map(month => allData.dataByMonth[month].central || 0);
            const centralDataEuro = centralDataKWH.map(kwh => kwh * costPerKWH);

            datasetsKWH.push({
                label: 'Zentraler Verbrauch',
                data: centralDataKWH,
                backgroundColor: COLORS.zentral,
                stack: 'Stack 0',
                order: 100, 
                datalabels: { formatter: (value) => value.toFixed(2) + ' kWh' }
            });

            datasetsEuro.push({
                label: 'Zentrale Kosten',
                data: centralDataEuro,
                backgroundColor: COLORS.zentral,
                stack: 'Stack 0',
                order: 100,
                datalabels: { formatter: (value) => value.toFixed(2) + ' €' }
            });
            
            // 2. Erzeugerdateien (PV) (Positive Säulen)
            allData.producerFiles.forEach((fileName, index) => {
                const producerDataKWH = months.map(month => allData.dataByMonth[month][fileName] || 0);
                const producerDataEuro = producerDataKWH.map(kwh => kwh * costPerKWH);

                const color = COLORS.erzeuger[colorIndex++ % COLORS.erzeuger.length];

                datasetsKWH.push({
                    label: `PV ${index + 1} (${fileName.split('.')[0]})`,
                    data: producerDataKWH,
                    backgroundColor: color,
                    stack: 'Stack 0',
                    order: 99 - index, 
                    datalabels: { formatter: (value) => value.toFixed(2) + ' kWh' }
                });

                datasetsEuro.push({
                    label: `PV Ersparnis ${index + 1}`,
                    data: producerDataEuro,
                    backgroundColor: color,
                    stack: 'Stack 0',
                    order: 99 - index,
                    datalabels: { formatter: (value) => value.toFixed(2) + ' €' }
                });
            });
            
            // 3. Rückspeisung (Gesamt) (Negative Säule, Rote Farbe)
            const netFeedInDataKWH = months.map(month => allData.dataByMonth[month].net_feed_in || 0);
            const netFeedInDataEuro = netFeedInDataKWH.map(kwh => kwh * costPerKWH); 

            datasetsKWH.push({
                label: 'Rückspeisung (Gesamt)', 
                data: netFeedInDataKWH,
                backgroundColor: COLORS.einspeisung,
                stack: 'Stack 0',
                order: 1, 
                datalabels: { formatter: (value) => Math.abs(value).toFixed(2) + ' kWh' }
            });

            datasetsEuro.push({
                label: 'Einspeise-Vergütung',
                data: netFeedInDataEuro,
                backgroundColor: COLORS.einspeisung,
                stack: 'Stack 0',
                order: 1,
                // Betrag verwenden und €-Zeichen davor
                datalabels: { formatter: (value) => Math.abs(value).toFixed(2) + ' €' }
            });

            // 4. EVU-Bezug (Gesamt) (Salden-Säule)
            const totalDataKWH = months.map(month => allData.dataByMonth[month].total || 0);
            const totalDataEuro = totalDataKWH.map(kwh => kwh * costPerKWH);

            datasetsKWH.push({
                label: 'EVU-Bezug (Gesamt)', 
                data: totalDataKWH,
                backgroundColor: COLORS.gesamt,
                stack: 'Stack 1', 
                order: 1, 
                datalabels: { formatter: (value) => value.toFixed(2) + ' kWh' }
            });
            
            datasetsEuro.push({
                label: 'Kosten/Ersparnis Saldo',
                data: totalDataEuro,
                backgroundColor: COLORS.gesamt,
                stack: 'Stack 1',
                order: 1,
                datalabels: { formatter: (value) => value.toFixed(2) + ' €' }
            });

            return { months, datasetsKWH, datasetsEuro };
        }

        let chartKWH, chartEURO;

        function renderCharts(data) {
            if (chartKWH) chartKWH.destroy();
            if (chartEURO) chartEURO.destroy();

            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { font: { size: 12 } }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: (context) => {
                                let label = context.dataset.label || '';
                                if (label) { label += ': '; }
                                // Absolute Werte für Netzeinspeisung im Tooltip, aber mit Vorzeichen, falls Saldo
                                let isSaldoOrBezug = context.dataset.label.includes('Saldo') || context.dataset.label.includes('Kosten') || context.dataset.label.includes('Bezug');
                                let value = isSaldoOrBezug ? context.formattedValue : Math.abs(context.parsed.y).toFixed(2);
                                let unit = context.chart.canvas.id === 'chart-kwh' ? ' kWh' : ' €';
                                return label + value + unit;
                            }
                        }
                    },
                    datalabels: {
                        // Hellere Farbe für bessere Sichtbarkeit auf dunklen Säulen
                        color: '#333333', 
                        font: { weight: 'bold', size: 11 }, // Etwas größere Schrift
                        align: 'center',
                        anchor: 'center',
                        rotation: 0,
                        // Anzeigen nur, wenn der Betrag > 0.01
                        formatter: (value) => Math.abs(value) > 0.01 ? value.replace('-', '') : null 
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        grid: { display: false }, // Entfernt unnötige Gitterlinien
                        title: { display: true, text: 'Monat', font: { size: 14, weight: 'bold' } }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: false, 
                        title: { display: true, text: 'Energie (kWh)', font: { size: 14, weight: 'bold' } }
                    }
                }
            };

            // Diagramm 1: kWh
            const ctxKWH = document.getElementById('chart-kwh').getContext('2d');
            chartKWH = new Chart(ctxKWH, {
                type: 'bar',
                data: {
                    labels: data.months,
                    datasets: data.datasetsKWH,
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Energie (kWh)' }
                        }
                    }
                }
            });

            // Diagramm 2: Euro
            const ctxEURO = document.getElementById('chart-euro').getContext('2d');
            chartEURO = new Chart(ctxEURO, {
                type: 'bar',
                data: {
                    labels: data.months,
                    datasets: data.datasetsEuro,
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Kosten/Ersparnis (€)' }
                        }
                    }
                }
            });
        }
    </script>
<script>
if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
        navigator.serviceWorker.register('service-worker.js')
        .then(function(registration) {
            console.log('Service Worker registriert mit Scope:', registration.scope);
        }, function(error) {
            console.log('Service Worker Registrierung fehlgeschlagen:', error);
        });
    });
}
</script></body>
</html>